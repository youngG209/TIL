# 제어자 (Modifier)

- 클래스와 클래스 멤버의 선언 시 사용하여 부가적인 의미를 부여하는 키워드를 의미
- 자바에서는 제어자를 접근 제어자(Access Modifier)와 기타 제어자로 구분

## 접근 제어자 (Access Modifier)

- 클래스 외부에서 직접적인 접근을 허용하지 않는 멤버를 설정하여 정보 은닉을 구체화할 수 있음

1. private 접근 제어자
   
    - 외부에 공개되지 않으며, 외부에서 직접 접근할 수 없음
    - 클래스 내부의 세부적인 동작을 구현하는데 사용, 선언된 클래스에서만 접근 가능
    
2. public
   
    - 외부로 공개되며, 해당 객체를 사용하는 프로그램 어디에서나 직접 접근할 수 있음
    - public 메소드는 private과 프로그램 사이의 인터페이스(interface) 역활을 수행한다 할 수 있음
    - 어디에서 누구나 접근 가능
    
3. default
   
    - 클래스 및 클래스 멤버의 접근 제어의 기본값으로 default 접근 제어를 별도로 명시하고 있음
    - 접근 제어자가 따로 존재하지 않으며, 접근 제어자가 따로 지정되지 않으면 자동적으로 default 접근 제어자가 됨
    - 같은 클래스의 멤버와 같은 패키지에 속한 멤버에서만 접근할 수 있음, 같은 패키지에 속하는 클래스에서만 접근
    
4. protected

    - 부모 클래스에서는 public, 외부에서는 private
    - 접근 영역
        1. 이 멤버를 선언한 클래스의 멤버
        2. 이 멤버를 선언한 클래스가 속한 패키지의 멤버
        3. 이 멤버를 선언한 클래스를 상속 받은 자식 클래스(Child Class)의 멤버
    
### 접근제어자의 접근 범위

- public > protected > default > private

| 접근 제어자 | 같은 클래스의 멤버 | 같은 패키지의 멤버 | 자식 클래스의 멤버 | 그 외의 영역
|--------|-----------|-----------|---------|----------
| public | O | O | O | O |
| protected | O | O | O | X |
| default | O | O | X | X |
| private | O | X | X | X |


## 기타 제어자

1. final 제어자
    
    - 필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수(constant)가 됨
    - 클래스에 사용하면 해당 클래스는 다른 클래스가 상속 받을 수 없게 됨
    - 메소드에 사용하면 해당 메소드는 오버라이딩(overriding)을 통한 재정의를 할 수 없게 됨
    - 사용 대상 : 클래스, 메소드, 필드, 지역 변수
    

        예제
            final class Car {                       // 이 클래스는 상속을 통해 서브 클래스를 생성할 수 없음
                final int VAR;                      // 이 필드는 상수화 되어 값을 변경할 수 없음
                final void brake() {                // 이 메소드는 오버라이딩을 통해 재정의할 수 없음
                    final double MAX_NUM = 10.2;    // 이 지역 변수는 상수화되어 값을 변경할 수 없음
                }
            }


2. static 제어자
    
    - 프로그램 시작 시 최조에 단 한 번만 생성되고 초기화 됨
    - 인스턴스를 생성하지 않고도 바로 사용할 수 있게 됨
    - 해당 클래스의 모든 인스턴스가 공유됨
    - 사용 대상 : 메소드, 필드, 초기화 블록


        예제
            class Car {                       
                static int var;         // 클래스 필드 (static 변수)
                static {                // static 초기화 블록
                    // 보통 클래스 필드의 초기화를 진행함.
                }
                static void brake() {   // 클래스 메소드 (static 메소드)
                    ......
                }
            }

3. abstract 제어자

    - 선언부만 있고 구현부가 없는 메소드를 추상 메소드라 하며, 반드시 abstract 제어자를 붙여야함
    - 하나 이상의 추상 메소드가 포함하고 있는 추상 클래스도 반드시 abstract 제어자를 붙여야함
    - 사용 대상 : 클래스, 메소드


        예제
            abstract class Car {            // 추상 클래스
                abstract void brake() {     // 추상 메소드
                    ......
                }
            }

## 제어자의 조합

- 자바에서는 접근 제어자와 기타 제어자를 한 대상에 함께 사용할 수 있습니다.
- 모든 경우가 가능한 것은 아니며, 대상에 따라 사용할 수 있는 조합이 따름

| 대상 | 함께 사용할 수 있는 제어자
|----|----
| 클래스 | public, (default), final, abstract
| 메소드 | 모든 접근 제어자, final, static, abstract
| 필드 | 모든 접근 제어자, final, static
| 지역 변수 | final
| 초기화 블록 : static

1. 클래스에 final과 abstract는 함께 사용 할 수 없음
    
    - final 제어자를 가지는 클래스는 다른 클래스가 상속 받을 수 없게 되며, abstract 제어자를 가지는 클래스는 다른 클래스가 상속해서 오버라이딩 해야만 사용 할 수 있으므로, 두 제어자는 클래스에 함께 사용 할 수 없음




2. 메소드에 static과 abstract는 함께 사용할 수 없음

    - abstract 제어자를 가지는 메소드는 선언부만 있고 구현부가 없는 메소드인데, static 제어자를 가지는 메소드는 인스턴스를 생성하지 않고도 바로 사용할 수 있어야 하므로, 이 두 제어자는 메소드에 함께 사용할 수 없음



3. 메소드에 private과 abstract는 함께 사용할 수 없음

    - abstract 제어자를 가지는 메소드는 다른 클래스가 상속하여 오버라이딩해야만 사용할 수 있는데, private 제어자를 가지는 메소드는 자식 클래스에서 접근할 수 없게 되므로, 이 두 제어자는 메소드에 함께 사용할 수 없음



4. 메소드에 private과 final은 함께 사용할 필요가 없음

    - 메소드에 사용된 final 제어자와 private 제어자는 모두 해당 메소드가 오버라이딩을 통한 재정의를 할 수 없다는 의미를 가지므로, 둘 중에 하나만 사용해도 의미가 충분히 전달될 수 있음


